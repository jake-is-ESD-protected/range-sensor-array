# range-sensor-array

### **[About](#about)**|**[Code](#code)**|**[Notes](#notes)**

## About
Repo for the embedded part of the SID SoSe23 project @TUB. Aims to create a driver for an 360Â° spanning array of HC-SR04 sensors for intrusion detection for a prototype of an autonomous outdoor cleaning robot using an ESP32 with the Arduino framework.

## Code

### [`platformio.ini`](./platformio.ini)
This is the projects build instruction and **only** works when using this project with [PlatformIO](https://platformio.org/) (*VSCode extension*). It is configured for two devices by Espressif, the **ESP32 AZ-Delivery Dev-Kit V4** and the **ESP32 WROVER-B**. As of now, using the **WROVER-B** is deprecated. We recommend using the `az-delivery-devkit-v4` environment for building. Furthermore, needed libraries such as the `MIDI Library` are compiled and an extra python script called [`build_ISRs.py`](#build_isrspy) is run before uploading the code to the controller. To change the upload port, specify the right port as `/dev/ttyUSBx` under a Linux-system or `COMx` under a Windows system. The relevant port can be seen under the `Devices` tab in the PlatformIO context window.


### [`main.cpp`](./src/main.cpp)
With a fixed integration of [FreeRTOS](https://www.freertos.org/RTOS.html) in the [ESP32 controller](https://www.espressif.com/en/products/socs/esp32) the program starts within a dedicated task and the `loop()` is left by itself. The executing function `sensorLoop()` is described in [`process`](#processcpph).

### [`process.cpp/h`](./lib/sensor/process.cpp)
General documentation on the used functions can be found at [process.h](./lib/sensor/process.h)  
The task initializes serial and MIDI lines and then enters an infinite loop. This loop triggers a pulse on all sensors **instantaneously** (because all `trigger` pins are galvanicly connected in hardware) and waits longer than the maximal return time of the ultrasonic signal before the results in the form of timestamps are collected. These get created in asynchronously called interrupts, described in [build_ISRs.py](#build_isrspy). The timestamps (stored within a static array) then get sorted by lowest value and converted into distances, which then either get printed for a human to read or converted to a MIDI CC value and sent over the serial line.

### [`build_ISRs.py`](./lib/sensor/build_ISRs.py)
Since the timestamps are acquired via interrupts, all 12 of them have to be defined during compile time. For this reason, this python script writes the needed code before all source files are uploaded. At the top of the file a user can specify the amount of sensors and the pins to which their `ECHO` pins are connected to. Each of the interrupts inputs the current system time into a unique index in the static timestamp array during its execution. This means that every time all of the sensors are triggered by the controller, different return signals will return at different times an fill each unique index. From this data, the minimum value (e.g. shortest distance, greatest intrusion) and even the intrusion direction can be computed (not implemented).

### [`sensor_ir.cpp/h`](./lib/sensor/sensor_ir.cpp)
Both files contain the needed interrupt declarations, definitions and initializations and are auto-generated by `build_ISRs.py`. **Do not modify them manually.** Instead, use `uild_ISRs.py` to change the setup.

## Notes
The sensors use heavy time based filtering to avoid "hiccups" and therefore have a noticeable delay when detecting intrusion. Additionally, the range is quite bad. In an open field, **no more than 2-3m** can be spotted reliably. 